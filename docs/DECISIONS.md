# 🎯 주요 의사결정 기록 (Decision Log)

이 문서는 Two-Tower 추천 시스템 개발 과정에서 내린 8가지 핵심 의사결정을 기록합니다.

## 1. 모델 아키텍처: Two-Tower

**결정**: Two-Tower (User Tower + Item Tower) 아키텍처 선택

**이유**:
- **독립적 임베딩**: 사용자와 아이템을 분리하여 임베딩하므로 아이템 벡터를 미리 계산하여 캐싱 가능
- **빠른 추론**: 런타임에 User Tower만 실행하고, 아이템 검색은 FAISS로 처리 (밀리초 단위)
- **확장성**: 새로운 아이템 추가 시 Item Tower만 재실행하면 됨
- **산업 검증**: YouTube, Google, Pinterest 등에서 검증된 아키텍처

**대안**:
- Single Tower (User + Item 동시 입력): 더 정확하지만 실시간 추론에 비효율적
- Matrix Factorization: 간단하지만 콘텐츠 기반 특징 활용 불가

## 2. Vector DB: FAISS

**결정**: FAISS (Facebook AI Similarity Search) 사용

**이유**:
- **성능**: 수백만 개 벡터에서 밀리초 단위 검색
- **메모리 효율**: 인덱스 압축 및 양자화 지원
- **무료 & 오픈소스**: 라이선스 비용 없음
- **CPU 모드**: 별도 GPU 없이도 충분히 빠름

**대안**:
- Pinecone/Weaviate: 관리형 서비스지만 비용 발생
- Elasticsearch: 범용 검색 엔진이지만 벡터 검색에 특화되지 않음
- Milvus: 좋은 선택이지만 설정이 복잡하고 데모에는 과함

## 3. 프론트엔드: React

**결정**: React 사용

**이유**:
- **생태계**: 풍부한 라이브러리 및 커뮤니티
- **개발 속도**: create-react-app으로 빠른 시작
- **유연성**: Context API로 간단한 상태 관리
- **채용 시장**: 개발자 풀이 큼

**대안**:
- Vue: 더 간단하지만 생태계가 상대적으로 작음
- Next.js: SSR 기능이 있지만 이 프로젝트에는 불필요

## 4. 백엔드 프레임워크: FastAPI

**결정**: FastAPI (Python) 사용

**이유**:
- **속도**: 비동기 처리로 Node.js 수준의 성능
- **자동 문서화**: Swagger UI 자동 생성
- **타입 힌팅**: Pydantic을 통한 자동 검증
- **ML 통합**: PyTorch/TensorFlow와 동일 언어로 통합 용이
- **생산성**: Python의 간결함

**대안**:
- Flask: 더 간단하지만 비동기 지원이 약함
- Node.js: 빠르지만 ML 모델 통합이 복잡

## 5. 배포 전략: 모놀리식 (1개 서버)

**결정**: 3개 애플리케이션을 1대의 서버에 배포

**이유**:
- **비용 절감**: VM 1대만 사용 (개발/데모 단계)
- **단순성**: 네트워크 설정 및 관리 포인트 최소화
- **충분한 성능**: 데모 수준의 트래픽에 충분
- **빠른 배포**: Docker/Kubernetes 없이도 간단히 배포

**대안**:
- 마이크로서비스 (각 서비스별 서버): 확장성은 좋지만 비용/복잡도 증가
- Serverless (Lambda): Cold start로 인한 지연 발생 가능

## 6. 인증 방식: JWT

**결정**: JWT (JSON Web Token) 기반 인증

**이유**:
- **Stateless**: 서버에 세션 저장 불필요 (확장성 향상)
- **자급적**: 토큰 자체에 사용자 정보 포함
- **표준화**: 산업 표준으로 라이브러리 지원 풍부
- **프론트엔드 친화적**: LocalStorage에 저장하여 SPA와 잘 맞음

**대안**:
- Session Cookie: 서버 상태 필요, 확장 시 Redis 등 추가 필요
- OAuth2: 외부 인증에는 좋지만 자체 인증에는 과함

## 7. 데이터베이스: SQLite (개발) / PostgreSQL (운영)

**결정**: SQLite로 개발, PostgreSQL로 운영

**이유**:
- **SQLite**:
  - 설정 불필요 (파일 기반)
  - 로컬 개발에 이상적
  - 가벼움
- **PostgreSQL** (운영):
  - 동시성 지원
  - 트랜잭션 안정성
  - 확장성

**대안**:
- MySQL: 좋은 선택이지만 PostgreSQL이 JSON 지원 등에서 더 우수
- MongoDB: NoSQL은 추천 시스템의 관계형 데이터에 비효율적

## 8. 오프라인 파이프라인: GitHub Actions + S3

**결정**: GitHub Actions로 일일 재학습, S3에 모델 저장

**이유**:
- **GitHub Actions**:
  - 무료 (월 2000분)
  - 코드와 CI/CD가 같은 곳에 위치
  - 크론 스케줄 지원
  - 설정 간단 (YAML)
- **S3**:
  - 저렴한 스토리지 비용
  - 높은 가용성 (99.99%)
  - SDK 지원 (boto3)
  - 버전 관리 가능

**대안**:
- Jenkins: 자체 서버 필요, 관리 복잡
- Airflow: 강력하지만 설정이 복잡하고 리소스 많이 사용
- Azure Blob / GCS: S3와 유사하지만 Yelp 데이터가 AWS에 있음

---

## 🔄 변경 이력

| 날짜 | 결정 항목 | 변경 내용 | 이유 |
|------|----------|----------|------|
| 2025-11-04 | 초기 작성 | 8가지 주요 의사결정 기록 | 프로젝트 시작 |

---

## 📌 향후 고려사항

### 확장 시 검토할 사항들:

1. **트래픽 증가 시**:
   - Redis 캐싱 추가 (추천 결과 캐싱)
   - 로드 밸런서 도입
   - DB 읽기 복제본 추가

2. **정확도 개선**:
   - Transformer 기반 더 복잡한 모델
   - Hard negative mining
   - Multi-task learning (클릭, 체류시간 등 동시 예측)

3. **실시간성 강화**:
   - Kafka/Kinesis로 스트리밍 파이프라인
   - 온라인 학습 (Incremental learning)
   - A/B 테스팅 프레임워크

4. **모니터링**:
   - Prometheus + Grafana
   - ML 모델 드리프트 감지
   - 비즈니스 메트릭 대시보드

---

이 의사결정들은 **데모 수준의 Two-Tower 추천 시스템**을 빠르게 구축하면서도, 향후 프로덕션 환경으로 확장 가능한 구조를 유지하도록 설계되었습니다.

